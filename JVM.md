# 类加载与字节码

```java
package cn.itcast.jvm.t5;
 // HelloWorld 示例
public class HelloWorld {
 	public static void main(String[] args) {
 		System.out.println("hello world");
 	}
}
```

编译为 HelloWorld.class 后:

```
 0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09
 0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07
 0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29
 0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e
 0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63
 0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01
 0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63
 0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f
 0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16
 0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72
 0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13
 0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69
 0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61
 0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46
 0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64
 0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e
 0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64
 0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74
 0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c
 0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61
 0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61
 0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f
 0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72
 0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76
 0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d
 0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a
 0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b
 0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01
 0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01
 0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00
 0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00
 0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00
 0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00
 0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a
 0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b
 0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00
 0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00
 0001120 00 00 02 00 14
```



## 1. 类文件结构

根据JVM规范，类文件结构：（各厂商在实现JVM时必须遵从该规范）

```
ClassFile {
    u4             magic; // 魔术
    u2             minor_version;// 小版本号
    u2             major_version;// 主版本号
    u2             constant_pool_count;// 常量池的数量
    cp_info        constant_pool[constant_pool_count-1];// 常量池信息
    u2             access_flags;// 访问修饰。（例如：该类是公共的还是私有的）
    u2             this_class;//当前类信息
    u2             super_class;//父类名信息
    u2             interfaces_count;//接口数量
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//类中字段数量
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//类中方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数。（类的附加属性信息）
    attribute_info attributes[attributes_count];//属性表集合
}
```

u4代表4个字节。

### 1.1 魔数

所有文件都有一个自己的特定类型，例如：java文件用4个字节表示这是一个java class文件，而不是其他的文件。

不同的文件有不同的魔数信息。例如，一个png或者jdp图片，它们的魔数信息是不同的。即魔数：标识该文件是什么类型。

java中，0~3字节，表示它是否是class类型文件，用 ca fe ba be表示。咖啡baby。

### 1.2 版本

4~7字节，表示类的版本。例如：00 00 00 34。这里小版本没有表示出来。主版本为00 34（16进制->10进制为 52）表示 jdk 8。 51 表示 jdk7。53 表示 jdk9。

### 1.3 常量池

8~9字节，表示常量池长度，常量池中项的数目。例如：00 23（16进制->10进制为 35）表示常量池中一共有35项（#1~#34项），注意：#0项不计入，也没有值。即，最终有34项。

![image-20250324115418546](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202503241154655.png)

第#1项 0a表示该常量项是什么类型。需要查表。例如：0a（10）-> CONSTANT_methodref 方法引用信息。方法信息的长度是固定的，接下来的4个字节就代表方法相关信息。例如：前两个字节为 00 06 代表 它引用了常量池中第#6项，代表方法的所属类。通过一层层查找，知道了 它是Object类的方法。具体是哪个方法，查看后两个字节为 00 15（21）代表它引用了常量池中第#21项，代表方法名信息。综上，第#1项 是Object类下的无参构造方法。即，通过 0a 00 06 00 15 我们可以知道：在常量池中有一项定义了方法，方法所属类和方法名通过查常量池中另外两项也可以知道。

第#2项 09 -> CONSTANT_Fieldref，表示是Field信息。后4个字节00 16（22） 00 17 （23）表示引用了常量池中#22和#23项获得该成员变量的所属类和成员变量名。综上，第#2项是System类下的一个成员变量，成员变量的名字是out，成员变量类型是PrintStream。

第#3项08 -> CONSTANT_String，表示一个字符串常量名称，后两个字节 00 18（24）表示引用了常量池中#24项。综上，第#3项是字符串常量“hello world”。

第#4项0a -> CONSTANT_methodref表示一个方法引用信息。后4个字节 00 19（25） 00 1a（26）表示引用了常量池中#25和#26项。综上，第#4项是 PrintStream类下的println方法，方法参数类型是String类，返回值类型是void 。

第#5项 07 -> CONSTANT_Class表示是Class信息，后两个字节 00 1b（27）代表 去查常量池中第#27项。是本类的信息。

第#6项 07 -> CONSTANT_Class表示是Class信息，后两个字节 00 1c（28）代表 去查常量池中第#28项，就知道Class信息了。是父类的信息。

第#7项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 06 表示该Utf8串的长度 6个字节。那么，查看接下来的6个字节 3c 69 6e 69 74 3e，转换成字符是 <init>。表示是一个init方法，即构造方法。 

第#8项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 03 表示该Utf8串的长度 3个字节。那么，查看接下来的3个字节 28 29 56 转换成字符是 ()V 。表示无参、无返回值。

第#9项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 04 表示该Utf8串的长度 4个字节。那么，查看接下来的4个字节，转换成字符是 Code。 代表方法的一个属性。字节码。

第#10项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 0f 表示该Utf8串的长度 15个字节。那么，查看接下来的15个字节，转换成字符是 LineNumberTable。 代表方法的一个属性。方法的行号表。

第#11项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 12 表示该Utf8串的长度 18个字节。那么，查看接下来的18个字节，转换成字符是 LocalVariableTable。 代表方法的一个属性。方法的本地变量表。

第#12项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 04 表示该Utf8串的长度 4个字节。那么，查看接下来的4个字节，转换成字符是 this。 

第#13项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 1d 表示该Utf8串的长度29个字节。那么，查看接下来的29个字节，转换成字符是 Lcn/itcast/jvm/t5/HeloWorld;。在字节码中，L开头，分号结尾，表示一个具体的类型。中间是类型的全路径。

第#14项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 04 表示该Utf8串的长度 4个字节。那么，查看接下来的4个字节，转换成字符是 main。

第#15项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 16 表示该Utf8串的长度 22个字节。那么，查看接下来的22个字节，转换成字符是 ([Ljava/lang/String;)V。表示字符串类型的数组。[表示是一个数组。返回值类型是void。

第#16项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 04 表示该Utf8串的长度 4个字节。那么，查看接下来的4个字节，转换成字符是 args。

第#17项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 13 表示该Utf8串的长度 19个字节。那么，查看接下来的19个字节，转换成字符是 [Ljava/lang/String;。进一步描述了一下args参数的类型，是一个字符串数组。

第#18项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 10 表示该Utf8串的长度 16个字节。那么，查看接下来的16个字节，转换成字符是 MethodParameters。代表方法的一个属性。方法的参数名称信息。

第#19项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 0a 表示该Utf8串的长度 10个字节。那么，查看接下来的10个字节，转换成字符是 SourceFile。代表类的一个属性。类的源文件。

第#20项 01 -> CONSTANT_Utf8表示是一个Utf8串，后两个字节00 0f 表示该Utf8串的长度 15个字节。那么，查看接下来的15个字节，转换成字符是 HelloWorld.java。即第#19 #20项结合起来就是，这个类的源文件是HelloWorld.java。

第#21项 0c ->  CONSTANT_NameAndType表示 名称+类型。后4个字节 00 07 00 08 代表引用了常量池中#7 #8两项，用来确定方法的名称和方法的参数类型、返回值类型。

第#22项 07 ->  CONSTANT_Class表示是Class信息。后两个字节 00 1d（29）引用了常量池中第#29项。

第#23项 0c ->  CONSTANT_NameAndType表示 名称+类型。后4个字节 00 1e（30） 00 1f（31） 代表引用了常量池中#30 #31两项，用来确定成员变量的名称和成员变量的类型。

第#24项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 0f（15） 代表 该Utf8串的长度 15个字节。那么，查看接下来的15个字节 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 ，转换成字符是 hello world。

第#25项 07 ->  CONSTANT_Class表示是Class信息。后两个字节 00 20（32）引用了常量池中第#32项。

第#26项 0c ->  CONSTANT_NameAndType表示 名称+类型。后4个字节 00 21（33） 00 22（34） 代表引用了常量池中#33 #34两项。用来确定方法的名称和方法的参数类型、返回值类型。

第#27项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 1b（27）代表 该Utf8串的长度 27个字节。那么，查看接下来的27个字节，转换成字符是 cn/itcast/jvm/t5/HelloWorld。即该类文件的包名+类名，即全限定名。

第#28项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 10（16）代表 该Utf8串的长度 16个字节。那么，查看接下来的16个字节 6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74，转换成字符是 java/lang/Object。表示这个是一个Object类。

第#29项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 10（16）代表 该Utf8串的长度 16个字节。那么，查看接下来的16个字节 6a 61 76 61 2f 6c 61 6e 67 2f 53 79 73 74 65 6d，转换成字符是java/lang/System。表示这个是一个System类。

第#30项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 03 代表 该Utf8串的长度 3个字节。那么，查看接下来的3个字节 6f 75 74 ，转换成字符是 out 。

第#31项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 15（21）代表 该Utf8串的长度 21个字节。那么，查看接下来的21个字节 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 3b 转换成字符是java/io/PrintStream。表示这个是一个PrintStream类。

第#32项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 13（19）代表 该Utf8串的长度 19个字节。那么，查看接下来的19个字节，转换成字符是java/io/PrintStream。表示这个是一个PrintStream类。

第#33项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 07 代表 该Utf8串的长度 7 个字节。那么，查看接下来的7个字节，转换成字符是 println。

第#34项 01-> CONSTANT_Utf8表示是一个Utf8串。后两个字节 00 15（21）代表 该Utf8串的长度 21个字节。那么，查看接下来的21个字节，转换成字符是 (java/lang/String;)V。表示println方法的参数类型是String类，返回值类型是void。

### 1.4 访问标识与继承信息

![image-20250324155934051](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202503241605060.png)

ACC_SUPER：表示一个类。

ACC_SYNTHETIC：表示是人工合成的，不是源代码。

ACC_ANNOTATION：表示是一个注解。

在常量池看完之后，接着往后看。

比如，后面两个字节是 00 21，那么查上面的表，看哪几项加起来是 00 21。可以看到，00 20 + 00 01 = 00 21。表示它是一个公共的类。

再往后两个字节是 00 05 表示本类的全限定名，从常量池中第#5项中找。

再往后两个字节是 00 06 表示父类的全限定名，从常量池中第#6项中找。

再往后两个字节是 00 00 表示接口的数量。这里为0，如果有的话 后面还会有一些接口的信息。

# 内存模型（Java Memory  Model-JMM）

JMM 定义了一套在**多线程**读写共享数据时（成员变量、数组）时，对数据的可见性、有序 性、和原子性的规则和保障

## 1.原子性

### 1.1问题

两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果不一定是0.

因为 Java 中对静态变量的自增，自减并不是原子操作。

例如，如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：

```
getstatic   i  // 获取静态变量i的值
iconst_1       // 准备常量1
iadd           // 加法
putstatic   i  // 将修改后的值存入静态变量i
```

java的内存模型：分为主内存和工作内存。

静态变量的自增和自减需要在主存和线程内存中进行数据交换。

![image-20250401155757723](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504011558980.png)

如果是单线程：顺序执行，不会交错执行。

```
// 假设i的初始值为0
getstatic     i  // 线程1：获取静态变量i的值 线程内i=0
iconst_1         // 线程1：准备常量1
iadd             // 线程1：自增，线程内i=1
putstatic     i  // 线程1：将修改后的值存入静态变量i 静态变量i=1

getstatic     i  // 线程1：获取静态变量i的值 线程内i=1
iconst_1         // 线程1：准备常量1
isub             // 线程1：自减，线程内i=0
putstatic     i  // 线程1：将修改后的值存入静态变量i 静态变量i=0
```

如果是多线程：由于cpu的时间片抢占式算法，因此会交错执行。

出现负数的情况：

```
// 假设i的初始值为0
getstatic     i  // 线程1：获取静态变量i的值 线程内i=0
getstatic     i  // 线程2：获取静态变量i的值 线程内i=0
iconst_1         // 线程1：准备常量1
iadd  			 // 线程1：自增，线程内i=1
putstatic     i  // 线程1：将修改后的值存入静态变量i 静态变量i=1
iconst_1         // 线程2：准备常量1
isub             // 线程2：自减，线程内i=-1
putstatic     i  // 线程2：将修改后的值存入静态变量i 静态变量i=-1
```

出现正数的情况：

```
// 假设i的初始值为0
getstatic     i  // 线程1：获取静态变量i的值 线程内i=0
getstatic     i  // 线程2：获取静态变量i的值 线程内i=0
iconst_1         // 线程1：准备常量1
iadd  			 // 线程1：自增，线程内i=1
iconst_1         // 线程2：准备常量1
isub             // 线程2：自减，线程内i=-1
putstatic     i  // 线程2：将修改后的值存入静态变量i 静态变量i=-1
putstatic     i  // 线程1：将修改后的值存入静态变量i 静态变量i=1
```

### 1.2解决方法

通过**synchonized**（同步关键字）保证原子性

```java
synchronized( 对象 ) { // 两个线程锁住的必须是同一个对象
	要作为原子操作代码
}
```

## 2.可见性

### 2.1问题

main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：

```java
static boolean run = true;

public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(() -> {
        while (run) {
            // .... 这里的循环会一直运行
        }
    });

    t.start();  // ① 启动子线程 t

    Thread.sleep(1000); // ② 主线程睡眠 1 秒

    run = false; // ③ 主线程修改 run 变量
}
```

分析：

1. 初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。

![image-20250401162421908](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504011624984.png)

2.因为 t 线程要频繁从主内存中读取 run 的值（每次while都会去读），JIT 编译器会将 run 的值缓存至自己工作内存中的高 速缓存中，减少对主存中 run 的访问，提高效率

![image-20250401162444465](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504011624538.png)

3.1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读 取这个变量的值，结果永远是旧值

![![](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504011625401.png)](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504011625401.png)

### 2.2解决方法

**volatile**（易变关键字）

可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主内存中获取它的值，线程操作 volatile 变量都是直接操作主内存中的对应变量。

### 2.3可见性

上述例子体现的就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一 个线程可见， 但不能保证原子性，仅适用于在一个写线程，多个读线程的情况。

即保证一个线程对 volatile 变量进行写操作后，其他线程读该 volatile 变量时可以读取到最新值。但是，在出现原子性问题时，是线程1已经读取到了变量，然后另线程2抢占了cpu执行权，那么当执行权回到线程1时，它不会再去主内存中读该变量，而是直接用之前已经读到的进行操作，因为volatile失效。

> synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized是属于重量级操作，性能相对更低。而volatile只能保证可见性。属于轻量级操作。

> synchronized可以保证原子性是因为：
>
> JMM规定了`synchronized` 的两大特性：
>
> 1.进入 `synchronized` 代码块时，必须从主内存读取共享变量的最新值（保证可见性）。
>
> 2.退出 `synchronized` 代码块时，必须将变量的修改刷新回主内存（保证修改对其他线程可见）。

### 2.4扩展

当在上述while循环中加入了：

```java
 System.out.println() // 例如: System.out.println(1) 
```

那么，此时不加volatile关键字也可以。

这是因为：

![image-20250401163905618](https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504011639741.png)

println方法内部使用了synchronized关键字，要对当前this，即PrintStream进行同步。那么就会强制当前线程读取主内存中的值，破坏了JIT的优化。

## 3.有序性

### 3.1问题

```java
    int num = 0;
    boolean ready = false;

    // 线程1 执行此方法
    public void actor1(I_Result r) {
        if (ready) {
            r.r1 = num + num;
        } else {
            r.r1 = 1;
        }
    }

    // 线程2 执行此方法
    public void actor2(I_Result r) {
        num = 2;
        ready = true;
    }
```

其中， I_Result 是一个对象，有一个属性 r1 用来保存结果。结果有几种？

分析：

1.线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1

2.线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1

3.线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（执行了num）

**4.**线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行  num = 2。

上述第4种现象叫做**指令重排**，是 JIT 编译器在运行时的一些优化。
