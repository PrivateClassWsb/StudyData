# java基础

## 为什么Java解释和编译都有？

回答：

在一般情况下，Java运行的流程是，首先将Java源代码编译成字节码文件，然后JVM再将字节码文件通过解释器逐行解释为机器码，然后运行。这就是Java的编译性和解释性。

后来，JVM中出现一个叫JIT（Just-In-Time）的即时编译技术，能够在在运行时将热点字节码通过编译器编译为机器码，而不再需要每次都解释，从而提高运行效率。这也是算是一种编译性。

所以，Java既是编译型也是解释性语言，默认采用的是解释器和编译器混合的模式。

# Redis

## Redis主从和集群可以保证数据一致性吗？

回答：

redis主从和集群在CAP理论都属于AP模型，即在面临网络分区时选择保证可用性和分区容忍性，而牺牲了强一致性。这意味着在网络分区的情况下，Redis主从复制和集群可以继续提供服务并保持可用，但可能会出现部分节点之间的数据不一致。

扩展:

1.Redis集群

Redis集群（Redis Cluster）是一种**分布式部署模式**，用于在多个节点之间分片存储数据，并提供高可用性。它通过**数据分片（sharding）**和**主从复制（master-slave replication）**来实现负载均衡和容错能力。

Redis集群的核心特点包括：

**数据被分片**到多个主节点（Master），每个主节点负责存储部分数据。

**多主多从架构（Multi-Master, Multi-Slave）：** 每个主节点（master）都管理一部分哈希槽，并可以有多个从节点（slave）进行数据同步，提供数据冗余和高可用性。

**故障转移（Failover）：** 当某个主节点宕机时，其从节点可以自动提升为主节点，以保证服务的连续性。

**不保证强一致性（Eventual Consistency）：** 由于主从复制是异步的，在网络分区或者节点故障的情况下，部分数据可能会丢失或出现数据不一致的情况。

2.CAP理论

CAP理论是分布式系统三大特性，描述了分布式系统在网络分区发生时，必须在一致性和可用性之间做出权衡。

> 网络分区（Network Partition）指的是 **在分布式系统中，某些服务器之间的网络连接发生故障，导致它们无法相互通信**，但系统的不同部分仍然可以对外提供服务。**“分区”** 就是指 **整个网络被分成了相互隔离的部分**，这些部分之间的数据无法互通。
>
> 例如：
>
> 假设有一个 **主从架构的 Redis**，`Master` 负责写入，`Slave` 负责备份数据。
>
> 如果 `Master` 和 `Slave` 之间的网络断开了（发生网络分区），会出现两种情况：
>
> 1. **Master 继续接受写入**，但 `Slave` 无法接收到新数据，导致数据不一致。（即AP）
> 2. **Redis 可能触发故障转移**，把 `Slave` 提升为新的 `Master`，但此时旧的 `Master` 仍然存在，两个 `Master` 可能会产生数据冲突。

**一致性（Consistency）：** 所有节点在同一时间点看到的数据是相同的。即所有读取请求都能返回最新写入的数据。

**可用性（Availability）：** 系统始终能够对请求做出响应，即使某些节点发生故障，系统仍能正常提供服务。

**分区容忍性（Partition Tolerance）：** 系统在遇到网络分区（即部分节点无法通信）时仍能继续运行。

CAP理论指出，在网络分区不可避免的情况下（P属性始终需要满足），分布式系统只能在一致性（C）和可用性（A）之间做选择。例如：

- **CP（强一致性 + 分区容忍）：** 牺牲可用性，在网络分区时可能拒绝请求以保证数据一致性。例如，Zookeeper、Etcd。
- **AP（高可用性 + 分区容忍）：** 牺牲强一致性，在网络分区时允许不同节点数据短暂不一致，以保证服务可用性。例如，Redis、Cassandra、DynamoDB。

# 并发编程

## syncronized锁升级过程

首先，`synchronized` 的锁升级是 JVM 为了优化同步性能而设计的一种机制，目的是在无竞争或低竞争的场景下减少锁的开销。

具体的锁升级的过程是：**无锁->偏向锁->轻量级锁->重量级锁**。

- **无锁：**当一个对象从未被用作 `synchronized` 关键字的目标锁，此时，它的锁状态是“无锁”。
- **偏向锁：**目的是优化同一个线程重复获取锁的场景，减少无竞争时的开销。当JVM 启用偏向锁（`-XX:+UseBiasedLocking`）且对象首次被用作同步锁时，JVM 通过 **CAS 操作** 将当前线程 ID写入对象头的 Mark Word。成功后，对象会进入**偏向锁状态**。当同一线程再次进入同步块时，只需检查对象头中的线程 ID 是否与当前线程 ID 一致。若一致，则表示同一个线程在重入，直接获取锁，无需任何同步操作（不需要进行CAS操作和将线程挂起的操作）。若不一致，触发偏向锁撤销（Revoke Bias），升级为轻量级锁。

> 匿名偏向：
>
> - 对象初始化后，如果偏向锁已启用（且已过 JVM 的偏向延迟时间），对象头会被 JVM **预先标记为可偏向状态**，但尚未绑定任何线程（线程 ID 为空）。
> - 此时锁处于“匿名偏向”状态，表示它已准备好偏向某个线程，但还未被实际使用。

- **轻量级锁：**目的是优化多个线程交替执行同步块，但实际无竞争的场景（如短时间自旋即可获得锁）。加锁时：在同步块入口，JVM 会在当前线程的栈帧中创建 `Lock Record`（锁记录），存储对象头的 Mark Word（01）。通过 CAS 尝试将对象头的 Mark Word 更新为指向 `Lock Record` 的指针（即将他们交换）。如果成功，锁标志位设为轻量级锁（`00`）；如果失败（即当另一个线程来进行cas时发现markword中是00不是01，代表已经被别人获得了轻量级锁），说明存在竞争，进入自旋等待（线程通过自旋（循环尝试获取锁）避免直接阻塞）（自旋超过阈值（默认约 10 次）升级为重量级锁）。解锁时：通过 CAS 将 Mark Word 还原回对象头。如果失败，说明锁已升级为重量级锁。

  > **什么是 `Lock Record`？**
  >
  > - **`Lock Record`** 是线程栈帧中的一块私有内存区域，用于存储轻量级锁的元数据。
  > - 每个线程在尝试获取轻量级锁时，会在自己的栈帧中创建一个 `Lock Record`。
  >
  > **将 Mark Word 更新为指向 `Lock Record` 的指针，具体操作过程：**
  >
  > 1. **保存原始 Mark Word**：
  >    JVM 会将对象头的原始 Mark Word **复制到 `Lock Record` 中**的**`displaced_header` 字段**（称为 **Displaced Mark Word**）。（这一步是为了在解锁时能够恢复对象的原始状态）
  > 2. **CAS 更新 Mark Word**：
  >    通过 CAS 操作，将对象头的 Mark Word **替换为指向当前线程的 `Lock Record` 的指针**，并将锁标志位设为轻量级锁（`00`）。
  > 3. **成功获取锁**：
  >    如果 CAS 成功，当前线程持有轻量级锁，对象头存储的是指向 `Lock Record` 的指针。

- **重量级锁：**目的是处理高竞争场景，通过操作系统互斥量（Mutex）实现线程阻塞。如果是轻量级锁，当有多个线程获取锁的时候，当CAS没有成功时始终都在自旋，进行while循环操作，这是非常消耗CPU的，但是在升级为重量级锁之后，线程会被操作系统调度然后挂起，这可以节约CPU资源。具体加锁是：将对象头的 Mark Word 指向一个 `Monitor` 对象。未获取锁的线程会被阻塞，进入操作系统的等待队列（涉及用户态到内核态的切换）。

  > **什么是 `Monitor`？**
  >
  > - **`Monitor`**（管程）是 JVM 在堆中创建的一个同步对象，与操作系统提供的互斥量（Mutex）关联。
  > - 每个 Java 对象在升级为重量级锁时，都会关联一个 `Monitor` 对象
  >
  > **将 Mark Word 指向一个 `Monitor` 对象，具体操作过程：**
  >
  > 1. **锁膨胀**：
  >    当轻量级锁竞争失败（如自旋超过阈值），JVM 会创建一个 `Monitor` 对象。
  > 2. **更新 Mark Word**：
  >    将对象头的 Mark Word **替换为指向当前线程的 `Monitor` 的指针**，锁标志位设为重量级锁（`10`）。
  > 3. **线程阻塞**：
  >    未获取锁的线程会被阻塞，进入 `Monitor` 的等待队列，依赖操作系统调度。

# 面经

## 滴滴

- 八股

  <img src="https://wsb-typora-picture.oss-cn-chengdu.aliyuncs.com/picgo/202504291011037.png" alt="image-20250429101151940" style="zoom:50%;" />







































